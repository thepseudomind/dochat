{"id":"../node_modules/react-scroll-to-bottom/lib/ScrollToBottom/Composer.js","dependencies":[{"name":"/Users/kenny/dochat/package.json","includedInParent":true,"mtime":1585906457517},{"name":"/Users/kenny/dochat/.babelrc","includedInParent":true,"mtime":1585328780539},{"name":"/Users/kenny/dochat/node_modules/react-scroll-to-bottom/package.json","includedInParent":true,"mtime":1585907404977},{"name":"prop-types","loc":{"line":8,"column":48},"parent":"/Users/kenny/dochat/node_modules/react-scroll-to-bottom/lib/ScrollToBottom/Composer.js","resolved":"/Users/kenny/dochat/node_modules/prop-types/index.js"},{"name":"react","loc":{"line":10,"column":44},"parent":"/Users/kenny/dochat/node_modules/react-scroll-to-bottom/lib/ScrollToBottom/Composer.js","resolved":"/Users/kenny/dochat/node_modules/react/index.js"},{"name":"simple-update-in","loc":{"line":12,"column":53},"parent":"/Users/kenny/dochat/node_modules/react-scroll-to-bottom/lib/ScrollToBottom/Composer.js","resolved":"/Users/kenny/dochat/node_modules/simple-update-in/lib/index.js"},{"name":"../EventSpy","loc":{"line":14,"column":47},"parent":"/Users/kenny/dochat/node_modules/react-scroll-to-bottom/lib/ScrollToBottom/Composer.js","resolved":"/Users/kenny/dochat/node_modules/react-scroll-to-bottom/lib/EventSpy.js"},{"name":"./FunctionContext","loc":{"line":16,"column":54},"parent":"/Users/kenny/dochat/node_modules/react-scroll-to-bottom/lib/ScrollToBottom/Composer.js","resolved":"/Users/kenny/dochat/node_modules/react-scroll-to-bottom/lib/ScrollToBottom/FunctionContext.js"},{"name":"./InternalContext","loc":{"line":18,"column":54},"parent":"/Users/kenny/dochat/node_modules/react-scroll-to-bottom/lib/ScrollToBottom/Composer.js","resolved":"/Users/kenny/dochat/node_modules/react-scroll-to-bottom/lib/ScrollToBottom/InternalContext.js"},{"name":"../SpineTo","loc":{"line":20,"column":46},"parent":"/Users/kenny/dochat/node_modules/react-scroll-to-bottom/lib/ScrollToBottom/Composer.js","resolved":"/Users/kenny/dochat/node_modules/react-scroll-to-bottom/lib/SpineTo.js"},{"name":"./StateContext","loc":{"line":22,"column":51},"parent":"/Users/kenny/dochat/node_modules/react-scroll-to-bottom/lib/ScrollToBottom/Composer.js","resolved":"/Users/kenny/dochat/node_modules/react-scroll-to-bottom/lib/ScrollToBottom/StateContext.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _simpleUpdateIn = _interopRequireDefault(require(\"simple-update-in\"));\n\nvar _EventSpy = _interopRequireDefault(require(\"../EventSpy\"));\n\nvar _FunctionContext = _interopRequireDefault(require(\"./FunctionContext\"));\n\nvar _InternalContext = _interopRequireDefault(require(\"./InternalContext\"));\n\nvar _SpineTo = _interopRequireDefault(require(\"../SpineTo\"));\n\nvar _StateContext = _interopRequireDefault(require(\"./StateContext\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar MIN_CHECK_INTERVAL = 17; // 1 frame\n\nvar NEAR_END_THRESHOLD = 1;\nvar SCROLL_DECISION_DURATION = 34; // 2 frames\n\nfunction setImmediateInterval(fn, ms) {\n  fn();\n  return setInterval(fn, ms);\n}\n\nfunction computeViewState(_ref) {\n  var mode = _ref.stateContext.mode,\n      _ref$target = _ref.target,\n      offsetHeight = _ref$target.offsetHeight,\n      scrollHeight = _ref$target.scrollHeight,\n      scrollTop = _ref$target.scrollTop;\n  var atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;\n  var atTop = scrollTop < NEAR_END_THRESHOLD;\n  var atEnd = mode === 'top' ? atTop : atBottom;\n  return {\n    atBottom: atBottom,\n    atEnd: atEnd,\n    atStart: !atEnd,\n    atTop: atTop\n  };\n}\n\nvar Composer =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Composer, _React$Component);\n\n  function Composer(props) {\n    var _this;\n\n    _classCallCheck(this, Composer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Composer).call(this, props));\n    _this.handleScroll = _this.handleScroll.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleScrollEnd = _this.handleScrollEnd.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._ignoreScrollEventBefore = 0;\n    _this.state = {\n      functionContext: {\n        scrollTo: function scrollTo(scrollTop) {\n          return _this.setState(function (_ref2) {\n            var stateContext = _ref2.stateContext;\n            return {\n              scrollTop: scrollTop,\n              stateContext: (0, _simpleUpdateIn.default)(stateContext, ['animating'], function () {\n                return true;\n              })\n            };\n          });\n        },\n        scrollToBottom: function scrollToBottom() {\n          return _this.state.functionContext.scrollTo('100%');\n        },\n        scrollToEnd: function scrollToEnd() {\n          var _assertThisInitialize = _assertThisInitialized(_assertThisInitialized(_this)),\n              _assertThisInitialize2 = _assertThisInitialize.state,\n              functionContext = _assertThisInitialize2.functionContext,\n              stateContext = _assertThisInitialize2.stateContext;\n\n          stateContext.mode === 'top' ? functionContext.scrollToTop() : functionContext.scrollToBottom();\n        },\n        scrollToStart: function scrollToStart() {\n          var _assertThisInitialize3 = _assertThisInitialized(_assertThisInitialized(_this)),\n              _assertThisInitialize4 = _assertThisInitialize3.state,\n              functionContext = _assertThisInitialize4.functionContext,\n              stateContext = _assertThisInitialize4.stateContext;\n\n          stateContext.mode === 'top' ? functionContext.scrollToBottom() : functionContext.scrollToTop();\n        },\n        scrollToTop: function scrollToTop() {\n          return _this.state.functionContext.scrollTo(0);\n        }\n      },\n      internalContext: {\n        offsetHeight: 0,\n        scrollHeight: 0,\n        setTarget: function setTarget(target) {\n          return _this.setState(function () {\n            return {\n              target: target\n            };\n          });\n        }\n      },\n      scrollTop: props.mode === 'top' ? 0 : '100%',\n      stateContext: {\n        animating: false,\n        atBottom: true,\n        atEnd: true,\n        atTop: true,\n        mode: props.mode,\n        sticky: true\n      },\n      target: null\n    };\n    return _this;\n  }\n\n  _createClass(Composer, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.enableWorker();\n    }\n  }, {\n    key: \"disableWorker\",\n    value: function disableWorker() {\n      clearInterval(this._stickyCheckTimeout);\n    }\n  }, {\n    key: \"enableWorker\",\n    value: function enableWorker() {\n      var _this2 = this;\n\n      clearInterval(this._stickyCheckTimeout);\n      var stickyButNotAtEndSince = false;\n      this._stickyCheckTimeout = setImmediateInterval(function () {\n        var state = _this2.state;\n        var sticky = state.stateContext.sticky,\n            target = state.target;\n\n        if (sticky && target && !computeViewState(state).atEnd) {\n          if (!stickyButNotAtEndSince) {\n            stickyButNotAtEndSince = Date.now();\n          } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {\n            // Quirks: In Firefox, after user scroll down, Firefox do two things:\n            //         1. Set to a new \"scrollTop\"\n            //         2. Fire \"scroll\" event\n            //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.\n            //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.\n            // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.\n            state.functionContext.scrollToEnd();\n            stickyButNotAtEndSince = false;\n          }\n        } else {\n          stickyButNotAtEndSince = false;\n        }\n      }, Math.max(MIN_CHECK_INTERVAL, this.props.checkInterval) || MIN_CHECK_INTERVAL);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.disableWorker();\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      this.setState(function (_ref3) {\n        var stateContext = _ref3.stateContext;\n        return {\n          stateContext: _objectSpread({}, stateContext, {\n            mode: nextProps.mode === 'top' ? 'top' : 'bottom'\n          })\n        };\n      });\n    }\n  }, {\n    key: \"handleScroll\",\n    value: function handleScroll(_ref4) {\n      var _this3 = this;\n\n      var timeStampLow = _ref4.timeStampLow;\n\n      // Currently, there are no reliable way to check if the \"scroll\" event is trigger due to\n      // user gesture, programmatic scrolling, or Chrome-synthesized \"scroll\" event to compensate size change.\n      // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.\n      if (timeStampLow <= this._ignoreScrollEventBefore) {\n        // Since we debounce \"scroll\" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).\n        // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.\n        // Thus, on a fast machine, adding elements super fast will lose the \"stickiness\".\n        return;\n      }\n\n      this.disableWorker();\n      this.setState(function (state) {\n        var target = state.target;\n\n        if (target) {\n          var internalContext = state.internalContext,\n              scrollTop = state.scrollTop,\n              stateContext = state.stateContext;\n\n          var _computeViewState = computeViewState(state),\n              atBottom = _computeViewState.atBottom,\n              atEnd = _computeViewState.atEnd,\n              atStart = _computeViewState.atStart,\n              atTop = _computeViewState.atTop;\n\n          var nextInternalContext = internalContext;\n          var nextStateContext = stateContext;\n          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atBottom'], function () {\n            return atBottom;\n          });\n          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atEnd'], function () {\n            return atEnd;\n          });\n          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atStart'], function () {\n            return atStart;\n          });\n          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atTop'], function () {\n            return atTop;\n          }); // Chrome will emit \"synthetic\" scroll event if the container is resized or an element is added\n          // We need to ignore these \"synthetic\" events\n          // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)\n          //        Nomatter how fast or slow the sequence is being presssed, it should still stick to the bottom\n\n          var offsetHeight = target.offsetHeight,\n              scrollHeight = target.scrollHeight;\n          var resized = offsetHeight !== internalContext.offsetHeight;\n          var elementChanged = scrollHeight !== internalContext.scrollHeight;\n\n          if (resized) {\n            nextInternalContext = (0, _simpleUpdateIn.default)(nextInternalContext, ['offsetHeight'], function () {\n              return offsetHeight;\n            });\n          }\n\n          if (elementChanged) {\n            nextInternalContext = (0, _simpleUpdateIn.default)(nextInternalContext, ['scrollHeight'], function () {\n              return scrollHeight;\n            });\n          } // Sticky means:\n          // - If it is scrolled programatically, we are still in sticky mode\n          // - If it is scrolled by the user, then sticky means if we are at the end\n          // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome\n\n\n          if (!resized && !elementChanged) {\n            nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['sticky'], function () {\n              return stateContext.animating ? true : atEnd;\n            });\n          } // If no scrollTop is set (not in programmatic scrolling mode), we should set \"animating\" to false\n          // \"animating\" is used to calculate the \"sticky\" property\n\n\n          if (scrollTop === null) {\n            nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['animating'], function () {\n              return false;\n            });\n          }\n\n          return _objectSpread({}, internalContext === nextInternalContext ? {} : {\n            internalContext: nextInternalContext\n          }, stateContext === nextStateContext ? {} : {\n            stateContext: nextStateContext\n          });\n        }\n      }, function () {\n        _this3.state.stateContext.sticky && _this3.enableWorker();\n      });\n    }\n  }, {\n    key: \"handleScrollEnd\",\n    value: function handleScrollEnd() {\n      // We should ignore debouncing handleScroll that emit before this time\n      this._ignoreScrollEventBefore = Date.now();\n      this.setState(function () {\n        return {\n          scrollTop: null\n        };\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var handleScroll = this.handleScroll,\n          handleScrollEnd = this.handleScrollEnd,\n          _this$props = this.props,\n          children = _this$props.children,\n          debounce = _this$props.debounce,\n          _this$state = this.state,\n          functionContext = _this$state.functionContext,\n          internalContext = _this$state.internalContext,\n          scrollTop = _this$state.scrollTop,\n          stateContext = _this$state.stateContext,\n          target = _this$state.target;\n      return _react.default.createElement(_InternalContext.default.Provider, {\n        value: internalContext\n      }, _react.default.createElement(_FunctionContext.default.Provider, {\n        value: functionContext\n      }, _react.default.createElement(_StateContext.default.Provider, {\n        value: stateContext\n      }, children, target && _react.default.createElement(_EventSpy.default, {\n        debounce: debounce,\n        name: \"scroll\",\n        onEvent: handleScroll,\n        target: target\n      }), target && scrollTop !== null && _react.default.createElement(_SpineTo.default, {\n        name: \"scrollTop\",\n        onEnd: handleScrollEnd,\n        target: target,\n        value: scrollTop\n      }))));\n    }\n  }]);\n\n  return Composer;\n}(_react.default.Component);\n\nexports.default = Composer;\nComposer.defaultProps = {\n  checkInterval: 100,\n  debounce: 17\n};\nComposer.propTypes = {\n  checkInterval: _propTypes.default.number,\n  debounce: _propTypes.default.number\n};\n"},"sourceMaps":{"js":{"version":3,"sources":["../../src/ScrollToBottom/Composer.js"],"names":["MIN_CHECK_INTERVAL","NEAR_END_THRESHOLD","SCROLL_DECISION_DURATION","setImmediateInterval","fn","ms","setInterval","computeViewState","mode","stateContext","target","offsetHeight","scrollHeight","scrollTop","atBottom","atTop","atEnd","atStart","Composer","props","handleScroll","bind","handleScrollEnd","_ignoreScrollEventBefore","state","functionContext","scrollTo","setState","scrollToBottom","scrollToEnd","scrollToTop","scrollToStart","internalContext","setTarget","animating","sticky","enableWorker","clearInterval","_stickyCheckTimeout","stickyButNotAtEndSince","Date","now","Math","max","checkInterval","disableWorker","nextProps","timeStampLow","nextInternalContext","nextStateContext","resized","elementChanged","children","debounce","React","Component","defaultProps","propTypes","PropTypes","number"],"mappings":"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","sourcesContent":["import PropTypes from 'prop-types';\nimport React from 'react';\nimport updateIn from 'simple-update-in';\n\nimport EventSpy from '../EventSpy';\nimport FunctionContext from './FunctionContext';\nimport InternalContext from './InternalContext';\nimport SpineTo from '../SpineTo';\nimport StateContext from './StateContext';\n\nconst MIN_CHECK_INTERVAL = 17;       // 1 frame\nconst NEAR_END_THRESHOLD = 1;\nconst SCROLL_DECISION_DURATION = 34; // 2 frames\n\nfunction setImmediateInterval(fn, ms) {\n  fn();\n\n  return setInterval(fn, ms);\n}\n\nfunction computeViewState({ stateContext: { mode }, target: { offsetHeight, scrollHeight, scrollTop } }) {\n  const atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;\n  const atTop = scrollTop < NEAR_END_THRESHOLD;\n  const atEnd = mode === 'top' ? atTop : atBottom;\n\n  return {\n    atBottom,\n    atEnd,\n    atStart: !atEnd,\n    atTop\n  };\n}\n\nexport default class Composer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.handleScroll = this.handleScroll.bind(this);\n    this.handleScrollEnd = this.handleScrollEnd.bind(this);\n\n    this._ignoreScrollEventBefore = 0;\n\n    this.state = {\n      functionContext: {\n        scrollTo: scrollTop => this.setState(({ stateContext }) => ({\n          scrollTop,\n          stateContext: updateIn(stateContext, ['animating'], () => true)\n        })),\n        scrollToBottom: () => this.state.functionContext.scrollTo('100%'),\n        scrollToEnd: () => {\n          const { state: { functionContext, stateContext } } = this;\n\n          stateContext.mode === 'top' ? functionContext.scrollToTop() : functionContext.scrollToBottom();\n        },\n        scrollToStart: () => {\n          const { state: { functionContext, stateContext } } = this;\n\n          stateContext.mode === 'top' ? functionContext.scrollToBottom() : functionContext.scrollToTop();\n        },\n        scrollToTop: () => this.state.functionContext.scrollTo(0)\n      },\n      internalContext: {\n        offsetHeight: 0,\n        scrollHeight: 0,\n        setTarget: target => this.setState(() => ({ target }))\n      },\n      scrollTop: props.mode === 'top' ? 0 : '100%',\n      stateContext: {\n        animating: false,\n        atBottom: true,\n        atEnd: true,\n        atTop: true,\n        mode: props.mode,\n        sticky: true\n      },\n      target: null\n    };\n  }\n\n  componentDidMount() {\n    this.enableWorker();\n  }\n\n  disableWorker() {\n    clearInterval(this._stickyCheckTimeout);\n  }\n\n  enableWorker() {\n    clearInterval(this._stickyCheckTimeout);\n\n    let stickyButNotAtEndSince = false;\n\n    this._stickyCheckTimeout = setImmediateInterval(\n      () => {\n        const { state } = this;\n        const { stateContext: { sticky }, target } = state;\n\n        if (\n          sticky\n          && target\n          && !computeViewState(state).atEnd\n        ) {\n          if (!stickyButNotAtEndSince) {\n            stickyButNotAtEndSince = Date.now();\n          } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {\n            // Quirks: In Firefox, after user scroll down, Firefox do two things:\n            //         1. Set to a new \"scrollTop\"\n            //         2. Fire \"scroll\" event\n            //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.\n            //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.\n            // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.\n\n            state.functionContext.scrollToEnd();\n            stickyButNotAtEndSince = false;\n          }\n        } else {\n          stickyButNotAtEndSince = false;\n        }\n      },\n      Math.max(MIN_CHECK_INTERVAL, this.props.checkInterval) || MIN_CHECK_INTERVAL\n    );\n  }\n\n  componentWillUnmount() {\n    this.disableWorker();\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.setState(({ stateContext }) => ({\n      stateContext: {\n        ...stateContext,\n        mode: nextProps.mode === 'top' ? 'top' : 'bottom'\n      }\n    }));\n  }\n\n  handleScroll({ timeStampLow }) {\n    // Currently, there are no reliable way to check if the \"scroll\" event is trigger due to\n    // user gesture, programmatic scrolling, or Chrome-synthesized \"scroll\" event to compensate size change.\n    // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.\n\n    if (timeStampLow <= this._ignoreScrollEventBefore) {\n      // Since we debounce \"scroll\" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).\n      // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.\n      // Thus, on a fast machine, adding elements super fast will lose the \"stickiness\".\n\n      return;\n    }\n\n    this.disableWorker();\n\n    this.setState(state => {\n      const { target } = state;\n\n      if (target) {\n        const { internalContext, scrollTop, stateContext } = state;\n        const { atBottom, atEnd, atStart, atTop } = computeViewState(state);\n        let nextInternalContext = internalContext;\n        let nextStateContext = stateContext;\n\n        nextStateContext = updateIn(nextStateContext, ['atBottom'], () => atBottom);\n        nextStateContext = updateIn(nextStateContext, ['atEnd'], () => atEnd);\n        nextStateContext = updateIn(nextStateContext, ['atStart'], () => atStart);\n        nextStateContext = updateIn(nextStateContext, ['atTop'], () => atTop);\n\n        // Chrome will emit \"synthetic\" scroll event if the container is resized or an element is added\n        // We need to ignore these \"synthetic\" events\n        // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)\n        //        Nomatter how fast or slow the sequence is being presssed, it should still stick to the bottom\n        const { offsetHeight, scrollHeight } = target;\n        const resized = offsetHeight !== internalContext.offsetHeight;\n        const elementChanged = scrollHeight !== internalContext.scrollHeight;\n\n        if (resized) {\n          nextInternalContext = updateIn(nextInternalContext, ['offsetHeight'], () => offsetHeight);\n        }\n\n        if (elementChanged) {\n          nextInternalContext = updateIn(nextInternalContext, ['scrollHeight'], () => scrollHeight);\n        }\n\n        // Sticky means:\n        // - If it is scrolled programatically, we are still in sticky mode\n        // - If it is scrolled by the user, then sticky means if we are at the end\n\n        // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome\n        if (!resized && !elementChanged) {\n          nextStateContext = updateIn(nextStateContext, ['sticky'], () => stateContext.animating ? true : atEnd);\n        }\n\n        // If no scrollTop is set (not in programmatic scrolling mode), we should set \"animating\" to false\n        // \"animating\" is used to calculate the \"sticky\" property\n        if (scrollTop === null) {\n          nextStateContext = updateIn(nextStateContext, ['animating'], () => false);\n        }\n\n        return {\n          ...internalContext === nextInternalContext ? {} : { internalContext: nextInternalContext },\n          ...stateContext === nextStateContext ? {} : { stateContext: nextStateContext }\n        };\n      }\n    }, () => {\n      this.state.stateContext.sticky && this.enableWorker();\n    });\n  }\n\n  handleScrollEnd() {\n    // We should ignore debouncing handleScroll that emit before this time\n    this._ignoreScrollEventBefore = Date.now();\n\n    this.setState(() => ({ scrollTop: null }));\n  }\n\n  render() {\n    const {\n      handleScroll,\n      handleScrollEnd,\n      props: { children, debounce },\n      state: { functionContext, internalContext, scrollTop, stateContext, target }\n    } = this;\n\n    return (\n      <InternalContext.Provider value={ internalContext }>\n        <FunctionContext.Provider value={ functionContext }>\n          <StateContext.Provider value={ stateContext }>\n            { children }\n            {\n              target &&\n                <EventSpy\n                  debounce={ debounce }\n                  name=\"scroll\"\n                  onEvent={ handleScroll }\n                  target={ target }\n                />\n            }\n            {\n              target && scrollTop !== null &&\n                <SpineTo\n                  name=\"scrollTop\"\n                  onEnd={ handleScrollEnd }\n                  target={ target }\n                  value={ scrollTop }\n                />\n            }\n          </StateContext.Provider>\n        </FunctionContext.Provider>\n      </InternalContext.Provider>\n    );\n  }\n}\n\nComposer.defaultProps = {\n  checkInterval: 100,\n  debounce: 17\n};\n\nComposer.propTypes = {\n  checkInterval: PropTypes.number,\n  debounce: PropTypes.number\n};\n"]}},"error":null,"hash":"1fb067ad3d023df49a640d55cbf1fc79","cacheData":{"env":{}}}